# P matrix of prior probabilities
# Add matrix with adducts connections
# Bio matrix with biochemical connections
# RT retention times vector
# relId relation id (group labels) vector, used to filtering masses
# corrMat correlation matrix (computed from the peak shapes)
# RTwin  RT vector, used to form a RTwin relation vector to filtering masses
# corrThld threshold for picking compounds in correlation matrix
# it iteration time for sampler
# burn burn value
# delIso delBio delAdd
# allSamp choose return value type
# unknownPen penalty value

"ComputePosteriorR_Add_Iso_Bio" <- function(P, Add, Iso, Bio, RT=NULL, relId=NULL,
                                        corrMat=NULL,  RTwin=3,
                                        corrThld=.80,it=1100, 
                                        burn=100, delAdd=.5, delIso=.5,
                                        delBio=1, allSamp=F,
                                        unknownPen=NULL, v = F){
  
    # if function receives no RT, relId, corr.matrix input, throw exception
    if(is.null(RT) & is.null(relId) & is.null(corrMat)){
      cat("\n Missing RT, corrMat or relId")
      stop()
    }
    
    # check whether RT,relId,corrMat has not null input, if not null and then response as:
    # RT: return a list called remIdx which contains all the vectors generated by checking.RT
    # relId: return a list called remIdx which contains all the vectors generated by checking.rel.id
    # corrMat: return a list called remIdx which contains all the vectors generated by checking.corr
    if(!is.null(RT)){
      counter <- 0
      remIdx <- lapply(RT, function(x){
        counter <<- counter + 1                                      # a flag
        CheckingRT(RT,counter, RTwin)                              # get a vector of which the elements are [counter, indexes] in RT which abs(RT[index] - RT[counter]) > RTwin
      })
    }else if(!is.null(relId)){
      counter <- 0
      remIdx <- lapply(relId, function(x){
        counter <<- counter + 1                                      # a flag
        CheckingRelId(relId,counter)                              # get a vector of which the elements are [counter, indexes] in relId which relId[index] != relId[counter]
      })
    }else{
      counter <- 0
      remIdx <- lapply(RT, function(x){
        counter <<- counter + 1                                      # a flag 
        CheckingCorr(corrMat[,counter],counter, corrThld)       # get a vector of which the elements are [indexes] in corrMat[,counter] which corrMat[,counter][index] < corrThld
      })
    }
     
    #return row number of adducts connections matrix
    Nc <- nrow(Add)
    #return row number of Prior probabilities matrix
    M <- nrow(P)
    
    #apply function multsample over rows of prior probabilities matrix 
    #about function multsample: doing sampling work
    #result: get a vector where each metabolite is assigned to a compound, e.g. sampcomp[x] = y indicates that mass of row x in matrix P 
    #        is assigned to compound of column y in matrix P
    sampcomp <- apply(P,1,multsample)

    # apply(,2,sum) is doing column sum operation on Add[sampcomp,]
    # Add[sampcomp,]: select specific rows, all columns from Add where row number indicates the compounds related to all the masses (referred from sampling)
    potAdd <-apply(Add[sampcomp,],2,sum)
    # apply(,2,sum) is doing column sum operation on Iso[sampcomp,]
    # Iso[sampcomp,]: select specific rows, all columns from Iso where row number indicates the compounds related to all the masses (referred from sampling) 
    potIso <-apply(Iso[sampcomp,],2,sum)
    # apply(,2,sum) is doing column sum operation on Bio[sampcomp,]
    # Bio[sampcomp,]: select specific rows, all columns from Bio where row number indicates the compounds related to all the masses (referred from sampling) 
    potBio <-apply(Bio[sampcomp,],2,sum)
    
    #create a matrix: row: iteration number
    #                 column: row number of Prior probabilities matrix, which is the mass number
    allsampcomp <- matrix(0, it, M) 
    # 
    # 
    for (i in 1:it){
        # create a vector radomly, from sampling, M : row number of Prior probabilities matrix
        ordine <- sample(M)
        # pick one mass, its index is row number 'thism' in Prior probabilities matrix
        # which indicates that this iteration is for mass 'thism'
        for (thism in ordine){

            # remIdx[[thism]] means when picking mass 'thism', only these masses can be counted into calculation of adduct relation
            # sampcomp[x] gives the compounds which can be counted into calculation of adduct relation
            # Add(CxC), Add[x,] picks out the relation matrix only concerned the compounds indicate by sampcomp[x]  # ncol = Nc is used when colSunms(a vector)
            # potAdd is a column sum operation on matrix S1(s1xc), Add(all the compounds related to all the masses which is refered by sampling, C) => S1(s1xc)
            # colSums() is doing column sum operation on matrix S2(s2xc), Add(all the compounds related to mass 'thism' which is refered by sampcomp[remIdx[[thism]]], C) => S2(s2xc)

            pAdd <- potAdd - colSums(matrix(Add[sampcomp[remIdx[[thism]]],], ncol=Nc))

            # remIdx[[thism]] means when picking mass 'thism', only these masses can be counted into calculation of adduct relation
            # sampcomp[x] gives the compounds which can be counted into calculation of isotope relation
            # Iso(CxC), Iso[x,] picks out the relation matrix only concerned the compounds indicate by sampcomp[x]  # ncol = Nc is used when colSunms(a vector)
            # potIso is a column sum operation on matrix S1(s1xc), Iso(all the compounds related to all the masses which is refered by sampling, C) => S1(s1xc)
            # colSums() is doing column sum operation on matrix S2(s2xc), Iso(all the compounds related to mass 'thism' which is refered by sampcomp[remIdx[[thism]]], C) => S2(s2xc)

            pIso <- potIso - colSums(matrix(Iso[sampcomp[remIdx[[thism]]],], ncol=Nc))

            # counting biotransformations
            # ncol = Nc is used when colSunms(a vector)

            pBio <- potBio - colSums(matrix(Bio[sampcomp[thism],], ncol=Nc))

            ## adding penalities, ##only into add relation and iso relation
            if(!is.null(unknownPen)){
              pAdd[length(pAdd)] <- unknownPen
              pIso[length(pIso)] <- unknownPen

            }

            # normalising with deltas
            pAdd <- (pAdd + delAdd)/sum(pAdd+delAdd)
            pIso <- (pIso + delIso)/sum(pIso+delIso)
            pBio <- (pBio + delBio)/sum(pBio+delBio)

            # merging scores, * means dot product
            po <- pAdd*pIso*pBio*P[thism,]

            # # eliminate negative value
            # po[po < 0] <- 0

            # normalise probability
            po <- po/sum(po)

            # get the origin sampling result of mass 'thism'
            oldval <- sampcomp[thism]
            # use normalised probability po to re-sample mass 'thism'
            sampcomp[thism] <- multsample(po)
            # potAdd: add relation vector (sum on columns) of all the masses
            # potIso: iso relation vector (sum on columns) of all the masses
            # potBio: bio relation vector (sum on columns) of all the masses
            # select a column from a matrix
            # if re-sample works, then
            if(oldval!=sampcomp[thism]){

                 # update potAdd, substract relation vector which indicates the add relation of compound 'oldval' with all compounds
                 # then add relation vector which indicates the add relation of compound sampcomp[thism] with all compounds

                 potAdd <- potAdd - Add[,oldval]
                 potAdd <- potAdd + Add[,sampcomp[thism]]

                 # update potIso, substract relation vector which indicates the iso relation of compound 'oldval' with all compounds
                 # then iso relation vector which indicates the iso relation of compound sampcomp[thism] with all compounds

                 potIso <- potIso - Iso[,oldval]
                 potIso <- potIso + Iso[,sampcomp[thism]]

                 # update potBio, substract relation vector which indicates the bio relation of compound 'oldval' with all compounds
                 # then bio relation vector which indicates the bio relation of compound sampcomp[thism] with all compounds

                 potBio <- potBio - Bio[,oldval]
                 potBio <- potBio + Bio[,sampcomp[thism]]
              }
    }
            # when finishing each iteration 'i'
            # get the whole new sampcomp vector, where each element(mess) get resampled using its po (posterior probability vector)
            # so, allsampcomp[i,] is the new sampcomp vector when finishing iteration 'i'
            allsampcomp[i,] <- sampcomp
            if(v){
              cat("Computing Posterior in R, ",paste0(round((i*100)/it,0), "%", "\n"))
            }
    }

    # calculate posterior probability using allsampcomp which is a sampling distribution matrix (row num: i; col num: m, which is the number of masses)
    # the calculation is completed by implementing function compute.post on every column of allsampcomp
    # Nc: row number of adducts connections matrix, which is the number of compounds
    post <- t(apply(allsampcomp,2,ComputePost, burn=burn, it=it, Nc=Nc))

    # decide which kind of value to return
    if(allSamp){
      out <- list(Post=post, allsampcomp=allsampcomp)
      return(out)
    }else{
      return(post)
    }

}
