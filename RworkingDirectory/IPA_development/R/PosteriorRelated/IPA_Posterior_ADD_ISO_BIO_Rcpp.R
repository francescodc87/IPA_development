# P matrix of prior probabilities
# Add matrix with adducts connections
# Bio matrix with biochemical connections
# RT retention times vector
# relId relation id (group labels) vector, used to filtering masses
# corrMat correlation matrix (computed from the peak shapes)
# RTwin  RT vector, used to form a RTwin relation vector to filtering masses
# corrThld threshold for picking compounds in correlation matrix
# it iteration time for sampler
# burn burn value
# delIso delBio delAdd
# allSamp choose return value type
# unknownPen penalty value

"ComputePosteriorRcpp_Add_Iso_Bio" <- function(P, Add, Iso, Bio, RT=NULL, relId=NULL,
                                      corrMat=NULL,  RTwin=3,
                                      corrThld=.80, it=1100, 
                                      burn=100, delAdd=.5, delIso=.5,
                                      delBio=1, allSamp=F,
                                      unknownPen=NULL, v = F){
  
  # if function receives no RT, relId, corr.matrix input, throw exception
  if(is.null(RT) & is.null(relId) & is.null(corrMat)){
    cat("\n Missing RT, corrMat or relId")
    stop()
  }
  
  # check whether RT,relId,corrMat has not null input, if not null and then response as:
  # RT: return a list called remIdx which contains all the vectors generated by checking.RT
  # relId: return a list called remIdx which contains all the vectors generated by checking.rel.id
  # corrMat: return a list called remIdx which contains all the vectors generated by checking.corr
  if(!is.null(RT)){
    counter <- 0
    remIdx <- lapply(RT, function(x){
      counter <<- counter + 1                                      # a flag
      CheckingRT(RT,counter, RTwin)                              # get a vector of which the elements are [counter, indexes] in RT which abs(RT[index] - RT[counter]) > RTwin
    })
  }else if(!is.null(relId)){
    counter <- 0
    remIdx <- lapply(relId, function(x){
      counter <<- counter + 1                                      # a flag
      CheckingRelId(relId,counter)                              # get a vector of which the elements are [counter, indexes] in relId which relId[index] != relId[counter]
    })
  }else{
    counter <- 0
    remIdx <- lapply(RT, function(x){
      counter <<- counter + 1                                      # a flag 
      CheckingCorr(corrMat[,counter],counter, corrThld)       # get a vector of which the elements are [indexes] in corrMat[,counter] which corrMat[,counter][index] < corr.thr
    })
  }
  
  #return row number of adducts connections matrix
  Nc <- nrow(Add)
  #return row number of Prior probabilities matrix
  M <- nrow(P)
  
  #apply function multsampleRcpp over rows of prior probabilities matrix 
  #about function multsampleRcpp: doing sampling work
  #result: get a vector where each metabolite is assigned to a compound, e.g. sampcomp[x] = y indicates that mass of row x in matrix P 
  #        is assigned to compound of column y in matrix P
  # sampcomp <- apply(P,1,multsampleRcpp)
  sampcomp <- apply(P,1,multsample)

  
  # apply(,2,sum) is doing column sum operation on Add[sampcomp,]
  # Add[sampcomp,]: select specific rows, all columns from Add where row number indicates the compounds related to all the masses (referred from sampling)
  potAdd <-apply(Add[sampcomp,],2,sum)
  # apply(,2,sum) is doing column sum operation on Iso[sampcomp,]
  # Iso[sampcomp,]: select specific rows, all columns from Iso where row number indicates the compounds related to all the masses (referred from sampling) 
  potIso <-apply(Iso[sampcomp,],2,sum)
  # apply(,2,sum) is doing column sum operation on Bio[sampcomp,]
  # Bio[sampcomp,]: select specific rows, all columns from Bio where row number indicates the compounds related to all the masses (referred from sampling) 
  potBio <-apply(Bio[sampcomp,],2,sum)
  

  post <- GibbsSampling(remIdx,
                        sampcomp,
                        potAdd,
                        potIso,
                        potBio,
                        as.matrix(Add),
                        as.matrix(Iso),
                        as.matrix(Bio),
                        P,
                        delAdd,
                        delIso,
                        delBio,
                        it,
                        burn,
                        v
                        )
  return (post)

}
