# P matrix of prior probabilities
# Add matrix with adducts connections
# Bio matrix with biochemical connections
# RT retention times vector
# rel.id relation id (group labels) vector, used to filtering masses
# Corr.matrix correlation matrix (computed from the peak shapes)
# RT.win  RT vector, used to form a RT.win relation vector to filtering masses
# corr.thr threshold for picking compounds in correlation matrix
# no.its iteration time for sampler
# burn burn value
# delta.iso delta.bio delta.add
# allsamp choose return value type
# unknown.pen penalty value

"IPA.sampler.Add.Iso.Bio.Rcpp" <- function(P, Add, Iso, Bio, RT=NULL, rel.id=NULL,
                                      Corr.matrix=NULL,  RT.win=3,
                                      corr.thr=.80,no.its=1100, 
                                      burn=100, delta.add=.5, delta.iso=.5,
                                      delta.bio=1, allsamp=F,
                                      unknown.pen=NULL){
  
  # if function receives no RT, rel.id, corr.matrix input, throw exception
  if(is.null(RT) & is.null(rel.id) & is.null(Corr.matrix)){
    cat("\n Missing RT, Corr.matrix or rel.id")
    stop()
  }
  
  # check whether RT,rel.id,Corr.matrix has not null input, if not null and then response as:
  # RT: return a list called ind.rem which contains all the vectors generated by checking.RT
  # rel.id: return a list called ind.rem which contains all the vectors generated by checking.rel.id
  # Corr.matrix: return a list called ind.rem which contains all the vectors generated by checking.corr
  if(!is.null(RT)){
    counter <- 0
    ind.rem <- lapply(RT, function(x){
      counter <<- counter + 1                                      # a flag
      checking.RT(RT,counter, RT.win)                              # get a vector of which the elements are [counter, indexes] in RT which abs(RT[index] - RT[counter]) > RT.win
    })
  }else if(!is.null(rel.id)){
    counter <- 0
    ind.rem <- lapply(rel.id, function(x){
      counter <<- counter + 1                                      # a flag
      checking.rel.id(rel.id,counter)                              # get a vector of which the elements are [counter, indexes] in rel.id which rel.id[index] != rel.id[counter]
    })
  }else{
    counter <- 0
    ind.rem <- lapply(RT, function(x){
      counter <<- counter + 1                                      # a flag 
      checking.corr(Corr.matrix[,counter],counter, corr.thr)       # get a vector of which the elements are [indexes] in Corr.matrix[,counter] which Corr.matrix[,counter][index] < corr.thr
    })
  }
  
  #return row number of adducts connections matrix
  Nc <- nrow(Add)
  #return row number of Prior probabilities matrix
  M <- nrow(P)
  
  #apply function multsampleRcpp over rows of prior probabilities matrix 
  #about function multsampleRcpp: doing sampling work
  #result: get a vector where each metabolite is assigned to a compound, e.g. sampcomp[x] = y indicates that mass of row x in matrix P 
  #        is assigned to compound of column y in matrix P
  sampcomp <- apply(P,1,multsampleRcpp)
  # sampcomp <- apply(P,1,multsample)
  # sampcomp <- c(1,2,3,15,5,7,10,11,9)
  
  # apply(,2,sum) is doing column sum operation on Add[sampcomp,]
  # Add[sampcomp,]: select specific rows, all columns from Add where row number indicates the compounds related to all the masses (referred from sampling)
  pot.add <-apply(Add[sampcomp,],2,sum)
  # apply(,2,sum) is doing column sum operation on Iso[sampcomp,]
  # Iso[sampcomp,]: select specific rows, all columns from Iso where row number indicates the compounds related to all the masses (referred from sampling) 
  pot.iso <-apply(Iso[sampcomp,],2,sum)
  # apply(,2,sum) is doing column sum operation on Bio[sampcomp,]
  # Bio[sampcomp,]: select specific rows, all columns from Bio where row number indicates the compounds related to all the masses (referred from sampling) 
  pot.bio <-apply(Bio[sampcomp,],2,sum)
  
  # #create a matrix: row: iteration number
  # #                 column: row number of Prior probabilities matrix, which is the mass number
  # allsampcomp <- matrix(0,no.its, M) 
  # 
  # 
  post <- gibbsSampling(ind.rem,
                        sampcomp,
                        pot.add,
                        pot.iso,
                        pot.bio,
                        Add,
                        Iso,
                        Bio,
                        P,
                        delta.add,
                        delta.iso,
                        delta.bio,
                        no.its,
                        burn
                        )
  return (post)

}
