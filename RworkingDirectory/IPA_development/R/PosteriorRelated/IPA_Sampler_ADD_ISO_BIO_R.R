# P matrix of prior probabilities
# Add matrix with adducts connections
# Bio matrix with biochemical connections
# RT retention times vector
# rel.id relation id (group labels) vector, used to filtering masses
# Corr.matrix correlation matrix (computed from the peak shapes)
# RT.win  RT vector, used to form a RT.win relation vector to filtering masses
# corr.thr threshold for picking compounds in correlation matrix
# no.its iteration time for sampler
# burn burn value
# delta.iso delta.bio delta.add
# allsamp choose return value type
# unknown.pen penalty value

"IPA.sampler.Add.Iso.Bio" <- function(P, Add, Iso, Bio, RT=NULL, rel.id=NULL,
                                        Corr.matrix=NULL,  RT.win=3,
                                        corr.thr=.80,no.its=1100, 
                                        burn=100, delta.add=.5, delta.iso=.5,
                                        delta.bio=1, allsamp=F,
                                        unknown.pen=NULL){
  
    # if function receives no RT, rel.id, corr.matrix input, throw exception
    if(is.null(RT) & is.null(rel.id) & is.null(Corr.matrix)){
      cat("\n Missing RT, Corr.matrix or rel.id")
      stop()
    }
    
    # check whether RT,rel.id,Corr.matrix has not null input, if not null and then response as:
    # RT: return a list called ind.rem which contains all the vectors generated by checking.RT
    # rel.id: return a list called ind.rem which contains all the vectors generated by checking.rel.id
    # Corr.matrix: return a list called ind.rem which contains all the vectors generated by checking.corr
    if(!is.null(RT)){
      counter <- 0
      ind.rem <- lapply(RT, function(x){
        counter <<- counter + 1                                      # a flag
        checking.RT(RT,counter, RT.win)                              # get a vector of which the elements are [counter, indexes] in RT which abs(RT[index] - RT[counter]) > RT.win
      })
    }else if(!is.null(rel.id)){
      counter <- 0
      ind.rem <- lapply(rel.id, function(x){
        counter <<- counter + 1                                      # a flag
        checking.rel.id(rel.id,counter)                              # get a vector of which the elements are [counter, indexes] in rel.id which rel.id[index] != rel.id[counter]
      })
    }else{
      counter <- 0
      ind.rem <- lapply(RT, function(x){
        counter <<- counter + 1                                      # a flag 
        checking.corr(Corr.matrix[,counter],counter, corr.thr)       # get a vector of which the elements are [indexes] in Corr.matrix[,counter] which Corr.matrix[,counter][index] < corr.thr
      })
    }
     
    #return row number of adducts connections matrix
    Nc <- nrow(Add)
    #return row number of Prior probabilities matrix
    M <- nrow(P)
    
    #apply function multsample over rows of prior probabilities matrix 
    #about function multsample: doing sampling work
    #result: get a vector where each metabolite is assigned to a compound, e.g. sampcomp[x] = y indicates that mass of row x in matrix P 
    #        is assigned to compound of column y in matrix P
    sampcomp <- apply(P,1,multsample)
    # sampcomp <- c(1,2,3,15,5,7,10,11,9)
    # apply(,2,sum) is doing column sum operation on Add[sampcomp,]
    # Add[sampcomp,]: select specific rows, all columns from Add where row number indicates the compounds related to all the masses (referred from sampling)
    pot.add <-apply(Add[sampcomp,],2,sum)
    # apply(,2,sum) is doing column sum operation on Iso[sampcomp,]
    # Iso[sampcomp,]: select specific rows, all columns from Iso where row number indicates the compounds related to all the masses (referred from sampling) 
    pot.iso <-apply(Iso[sampcomp,],2,sum)
    # apply(,2,sum) is doing column sum operation on Bio[sampcomp,]
    # Bio[sampcomp,]: select specific rows, all columns from Bio where row number indicates the compounds related to all the masses (referred from sampling) 
    pot.bio <-apply(Bio[sampcomp,],2,sum)
    
    #create a matrix: row: iteration number
    #                 column: row number of Prior probabilities matrix, which is the mass number
    allsampcomp <- matrix(0,no.its, M) 
    #iterator
    for (it in 1:no.its){
        # create a vector radomly, from sampling, M : row number of Prior probabilities matrix
        ordine <- sample(M)  
        
        # pick one mass, its index is row number 'thism' in Prior probabilities matrix
        # which indicates that this iteration is for mass 'thism'
        for (thism in ordine){
            
            # ind.rem[[thism]] means when picking mass 'thism', only these masses can be counted into calculation of adduct relation
            # sampcomp[x] gives the compounds which can be counted into calculation of adduct relation
            # Add(CxC), Add[x,] picks out the relation matrix only concerned the compounds indicate by sampcomp[x]  # ncol = Nc is used when colSunms(a vector)
            # pot.add is a column sum operation on matrix S1(s1xc), Add(all the compounds related to all the masses which is refered by sampling, C) => S1(s1xc)
            # colSums() is doing column sum operation on matrix S2(s2xc), Add(all the compounds related to mass 'thism' which is refered by sampcomp[ind.rem[[thism]]], C) => S2(s2xc)
            
            p.add <- pot.add - colSums(matrix(Add[sampcomp[ind.rem[[thism]]],], ncol=Nc))
          
            # ind.rem[[thism]] means when picking mass 'thism', only these masses can be counted into calculation of adduct relation
            # sampcomp[x] gives the compounds which can be counted into calculation of isotope relation
            # Iso(CxC), Iso[x,] picks out the relation matrix only concerned the compounds indicate by sampcomp[x]  # ncol = Nc is used when colSunms(a vector)
            # pot.iso is a column sum operation on matrix S1(s1xc), Iso(all the compounds related to all the masses which is refered by sampling, C) => S1(s1xc)
            # colSums() is doing column sum operation on matrix S2(s2xc), Iso(all the compounds related to mass 'thism' which is refered by sampcomp[ind.rem[[thism]]], C) => S2(s2xc)
            
            p.iso <- pot.iso - colSums(matrix(Iso[sampcomp[ind.rem[[thism]]],], ncol=Nc))
            
            # counting biotransformations
            # ncol = Nc is used when colSunms(a vector)
            
            p.bio <- pot.bio - colSums(matrix(Bio[sampcomp[thism],], ncol=Nc))
            
            ## adding penalities, ##only into add relation and iso relation
            if(!is.null(unknown.pen)){
              p.add[length(p.add)] <- unknown.pen
              p.iso[length(p.iso)] <- unknown.pen
              
            } 
            
            # normalising with deltas
            p.add <- (p.add + delta.add)/sum(p.add+delta.add)
            p.iso <- (p.iso + delta.iso)/sum(p.iso+delta.iso)
            p.bio <- (p.bio + delta.bio)/sum(p.bio+delta.bio)
            
            # merging scores, * means dot product
            po <- p.add*p.iso*p.bio*P[thism,]
            # po <- P[thism,]
              # po <- p.bio
            # normalise probability
            po <- po/sum(po)
            
            # get the origin sampling result of mass 'thism'
            oldval <- sampcomp[thism]

            # use normalised probability po to re-sample mass 'thism'
            sampcomp[thism] <- multsample(po)

            # pot.add: add relation vector (sum on columns) of all the masses
            # pot.iso: iso relation vector (sum on columns) of all the masses
            # pot.bio: bio relation vector (sum on columns) of all the masses
            # select a column from a matrix
            # if re-sample works, then
            if(oldval!=sampcomp[thism]){

                 # update pot.add, substract relation vector which indicates the add relation of compound 'oldval' with all compounds
                 # then add relation vector which indicates the add relation of compound sampcomp[thism] with all compounds

                 pot.add <- pot.add - Add[,oldval]
                 pot.add <- pot.add + Add[,sampcomp[thism]]

                 # update pot.iso, substract relation vector which indicates the iso relation of compound 'oldval' with all compounds
                 # then iso relation vector which indicates the iso relation of compound sampcomp[thism] with all compounds

                 pot.iso <- pot.iso - Iso[,oldval]
                 pot.iso <- pot.iso + Iso[,sampcomp[thism]]

                 # update pot.bio, substract relation vector which indicates the bio relation of compound 'oldval' with all compounds
                 # then bio relation vector which indicates the bio relation of compound sampcomp[thism] with all compounds

                 pot.bio <- pot.bio - Bio[,oldval]
                 pot.bio <- pot.bio + Bio[,sampcomp[thism]]
              }
        }
            # when finishing each iteration 'it'
            # get the whole new sampcomp vector, where each element(mess) get resampled using its po (posterior probability vector)
            # so, allsampcomp[it,] is the new sampcomp vector when finishing iteration 'it'
            allsampcomp[it,] <- sampcomp
    }
    
    # calculate posterior probability using allsampcomp which is a sampling distribution matrix (row num: no.its; col num: m, which is the number of masses)
    # the calculation is completed by implementing function compute.post on every column of allsampcomp
    # Nc: row number of adducts connections matrix, which is the number of compounds
    post <- t(apply(allsampcomp,2,compute.post, burn=burn, no.its=no.its, Nc=Nc))
    # 
    # decide which kind of value to return
    if(allsamp){
      out <- list(Post=post, allsampcomp=allsampcomp)
      return(out)
    }else{
      return(post)  
    }
}
